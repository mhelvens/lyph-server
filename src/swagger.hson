{
	swagger: '2.0',
	info: {
		title: "Open Physiology Lyph System",
		description: "REST API for anatomical lyph systems and related constructs"
	},
	host: 'http://localhost:3000',
	consumes: ['application/json'],
	produces: ['application/json'],
	definitions: {

		////////////////////////////////////////

		Key: {
			type: 'object',
			properties: { type: 'string' },
			required: true,
			'x-skipDB': true
		},

		KeyList: {
			type: 'array',
			items: { $ref: '#/definitions/Key' },
			'x-skipDB': true
		},

		////////////////////////////////////////

		LyphTemplate: {
			type: 'object',
			properties: {
				name:   { type: 'string', required: true },
				layers: { $ref: '#/definitions/KeyList' }
			}
		},

		LayerTemplate: {
			type: 'object',
			properties: {
				name:         { type: 'string' },
				lyphTemplate: { $ref: '#/definitions/Key' },
				position:     { type: 'integer', minimum: 0 },
				thickness:    {
					// array of [min, max]
					type: 'array',
					items: { type: 'number', minimum: 0 },
					minItems: 2,
					maxItems: 2,
					required: true
				}
			}
		}

		// TODO: finish data-types

		////////////////////////////////////////




	},
	paths: {

		// TODO: enforce that name/uri-ish fields are not empty strings

		'/lyphTemplates': {
			get: {
				summary: "find all lyph templates",
				responses: {

				}
			},
			post: {
				summary: "create a new lyph template",
				responses: {

				}
			}
		},

		'/lyphTemplates/{id}': {
			get: {
				summary: "find lyph templates by id",
				responses: {

				}
			},
			put: {
				summary: "replace a particular lyph template",
				responses: {

				}
			},
			post: {
				summary: "update a particular lyph template",
				responses: {

				}
			},
			delete: {
				summary: "delete a particular lyph template",
				responses: {

				}
			}
		},

		'/lyphTemplates/{id}/layers': {
			get: {
				summary: "find all the layers of a particular lyph template",
				responses: {

				}
			},
			post: {
				summary: "create and add a layer to a particular lyph template",
				responses: {

				}
			}
		},

		'/lyphTemplates/{id}/layers/{id2}': {
			put: {
				summary: "add a particular layer to a particular lyph template",
				responses: {

				}
			},
			delete: {
				summary: "delete a layer from a particular lyph template",
				responses: {

				}
			}
		},

		'/lyphTemplates/{id}/materialIn': {
			get: {
				summary: "find the layer templates in which a particular lyph is a material",
				responses: {

				}
			}
		},

		'/lyphTemplates/{id}/materialIn/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/lyphTemplates/{id}/instantiations': {
			get: {
				summary: "find all layers instantiated from a particular lyph template",
				responses: {

				}
			}
			// intentionally no other verbs (instantiation has 1 template from creation)
		},

		// intentionally no "/lyphTemplates/{id}/instantiatedLyphs/{id2}" (instantiation has 1 template from creation)

		'/layerTemplates': { // field: lyphTemplate
			get: {
				summary: "find all lyph-layer templates",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/layerTemplates/{id}': {
			get: {
				summary: "find lyph-layer templates by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/layerTemplates/{id}/materials': {
			// = set of lyphTemplates
			get: {
				summary: "find all lyph templates acting as materials in a particular layer template",
				responses: {

				}
			}
		},

		'/layerTemplates/{id}/materials/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			},
		},

		'/layerTemplates/{id}/instantiations': {
			get: {
				summary: "find all layers instantiated from a particular layer template",
				responses: {

				}
			}
			// intentionally no other verbs (instantiation has 1 template from creation)
		},

		// intentionally no "/layerTemplates/{id}/instantiations/{id2}" (instantiation has 1 template from creation)

		'/lyphs': {
			// fields: template, closedAt (0 or more of ['plus', 'minus'])
			get: {
				summary: "find all lyphs",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/lyphs/{id}': {
			get: {
				summary: "find lyphs by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/lyphs/{id}/layers': {
			get: {
				summary: "find all the layers of a particular lyph",
				responses: {

				}
			}
			// intentionally no other verbs (layers sync through templates)
		},

		// intentionally no "/lyphs/{id}/layers/{id2}" (layers sync through templates)

		'/lyphs/{id}/locatedMeasures': {
			get: {
				summary: "find all located measures located in a particular lyph",
				responses: {

				}
			}
		},

		'/lyphs/{id}/locatedMeasures/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/lyphs/{id}/inCompartments': {
			get: {
				summary: "find all compartments in which a particular lyph is a member",
				responses: {

				}
			}
		},

		'/lyphs/{id}/inCompartments/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/lyphs/{id}/inLayers': {
			// TODO: enforce that if a lyph is in more than 1 layer, that all those layers coalesce
			get: {
				summary: "find the layer(s) in which a particular lyph is located",
				responses: {

				}
			}
		},

		'/lyphs/{id}/inLayers/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/layers': {
			// fields: template
			get: {
				summary: "find all lyph-layers",
				responses: {

				}
			}
			// intentionally no other verbs (layers sync through templates)
		},

		'/layers/{id}': {
			get: {
				summary: "find lyph-layers by id",
				responses: {

				}
			}
			// intentionally no other verbs (layers sync through templates)
		},

		'/layers/{id}/lyphs': {
			get: {
				summary: "find all lyphs that are located in a particular layer",
				responses: {

				}
			}
		},

		'/layers/{id}/lyphs/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},



		//////////////////////////////////////// TODO: NODES IN LAYERS NEED A DECISION MADE:
		////////////////////////////////////////     : http://stackoverflow.com/q/32340071/681588
		//
		'/layers/{id}/nodes': {
			get: {
				// returns a list of objects { border, node }
				summary: "find all nodes that are located on the borders of a particular layer",
				responses: {

				}
			}
		},

		'/layers/{id}/nodes/{id2}': {
			put: {
				// expects an object { border }
				summary: "",
				responses: {

				}
			},
			delete: {
				// expects an object { border }
				summary: "",
				responses: {

				}
			}
		},
		//
		////////////////////////////////////////



		'/layers/{id}/coalescesWith': {
			// set of other layers
			// TODO: enforce symmetry of coalescence
			// TODO: enforce that each coalescing layer is the outermost layer of its lyph
			// TODO: enforce that all coalescing layers have the same layer template
			get: {
				summary: "find all layers that coalesce with a particular other layer",
				responses: {

				}
			}
		},

		'/layers/{id}/coalescesWith/{id2}': {
			// set of other layers
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		// TODO: avoid loops in "/layerTemplates/{id}/materials" + "/lyphTemplates/{id}/layers" relationships
		// TODO: avoid loops in "/lyphs/{id}/layers"             + "/layers/{id}/lyphs"         relationships
		// TODO: enforce that the positions of layers start at 0 and are sequential / without gaps

		// DONE: enforce that layers of instantiated lyphs correspond to the layer(Template)s of the lyph template
		// done by auto-syncing from layerTemplates to layers

		'/compartments/{id}/lyphs': {
			get: {
				summary: "find all lyphs that are members of a particular compartment",
				responses: {

				}
			}
		},

		'/compartments/{id}/lyphs/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/nodes': {
			get: {
				summary: "find all nodes",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/nodes/{id}': {
			get: {
				summary: "find nodes by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},



		//////////////////////////////////////// TODO: NODES IN LAYERS NEED A DECISION MADE:
		////////////////////////////////////////     : http://stackoverflow.com/q/32340071/681588
		//
		'/nodes/{id}/attachments': {
			// with border-specification
			get: {
				summary: "find all borders attached to a specific node",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/nodes/{id}/attachments/{id2}': {
			// with border-specification
			delete: {
				summary: "",
				responses: {

				}
			}
		},
		//
		////////////////////////////////////////



		// TODO: enforce that a node is not on the inner border of layer 0 (the axis)
		// TODO: enforce that a node cannot be on more than one border of the same layer
		// TODO: enforce that when a node is placed 'between' layers, it is registered on both (inner, outer)
		// TODO: enforce node placement w.r.t. coalescence
		// TODO: if a node is on plus/minus of lyphA(layer i), and on outer/inner of lyphB(layer j),
		//     : then lyphA is inside of lyphB(layer j +/- 1)
		//     : (unless it's the outer border of the outer layer of lyphB; then it's not necessary)
		//     : IN OTHER WORDS: orthogonal placement of lyph inside housing layer


		'/correlations': {
			// field: publication
			get: {
				summary: "find all correlations",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/correlations/{id}': {
			get: {
				summary: "find correlations by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/correlations/{id}/clinicalIndices': {
			get: {
				summary: "find all clinical indices involved in a specific correlation",
				responses: {

				}
			}
		},

		'/correlations/{id}/clinicalIndices/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/correlations/{id}/locatedMeasures': {
			get: {
				summary: "find all located measures involved in a specific correlation",
				responses: {

				}
			}
		},

		'/correlations/{id}/locatedMeasures/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		// TODO: enforce that a correlation has >= 2 variables associated with it

		'/publications': {
			get: {
				summary: "find all publications",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/publications/{id}': {
			// fields: uri (e.g., pubmed)
			get: {
				summary: "find publications by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/publications/{id}/correlations': {
			get: {
				summary: "find all correlations described in a particular publication",
				responses: {

				}
			}
		},

		'/publications/{id}/correlations/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		// TODO: enforce that no two publications have the same 'pubmed uri'

		'/clinicalIndices': {
			get: {
				summary: "find all clinical indices",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/clinicalIndices/{id}': {
			get: {
				summary: "find clinical indices by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/clinicalIndices/{id}/correlations': {
			get: {
				summary: "find all correlations in which a particular clinical index is involved",
				responses: {

				}
			}
		},

		'/clinicalIndices/{id}/correlations/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/locatedMeasures': {
			get: {
				summary: "find all located measures",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/locatedMeasures/{id}': {
			// field: lyph
			get: {
				summary: "find located measures by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/locatedMeasures/{id}/correlations': {
			get: {
				summary: "find all correlations in which a particular located measure is involved",
				responses: {

				}
			}
		},

		'/locatedMeasures/{id}/correlations/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/locatedMeasures/{id}/bagsOfPathologies': {
			get: {
				summary: "find all bags of pathologies in which a particular located measure is involved",
				responses: {

				}
			}
		},

		'/locatedMeasures/{id}/bagsOfPathologies/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/bagsOfPathologies': {
			get: {
				summary: "find all bags of pathologies",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}': {
			get: {
				summary: "find bags of pathologies by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}/locatedMeasures': {
			get: {
				summary: "find all located measures associated with a specific bag of pathologies",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}/locatedMeasures/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}/removedProcesses': {
			get: {
				summary: "find all processes removed by a specific bag of pathologies",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}/removedProcesses/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}/addedProcesses': {
			get: {
				summary: "find all potential processes added by a specific bag of pathologies",
				responses: {

				}
			}
		},

		'/bagsOfPathologies/{id}/addedProcesses/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		// TODO: enforce that a bag of pathologies has at least one 'thing' in it

		'/potentialProcesses': {
			// fields: from, to (nodes)
			get: {
				summary: "find all potential processes",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/potentialProcesses/{id}': {
			get: {
				summary: "find potential processes by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/potentialProcesses/{id}/addedByBagsOfPathologies': {
			get: {
				summary: "find all bags of pathologies that add a particular potential process",
				responses: {

				}
			}
		},

		'/potentialProcesses/{id}/addedByBagsOfPathologies/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		'/processes': {
			// fields: from, to (nodes)
			get: {
				summary: "find all processes",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			}
		},

		'/processes/{id}': {
			get: {
				summary: "find processes by id",
				responses: {

				}
			},
			put: {
				summary: "",
				responses: {

				}
			},
			post: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		},

		// TODO: enforce that a process does not go from x to y, when x and y are on the same border

		'/processes/{id}/removedByBagsOfPathologies': {
			get: {
				summary: "find all bags of pathologies that remove a particular process",
				responses: {

				}
			}
		},

		'/processes/{id}/removedByBagsOfPathologies/{id2}': {
			put: {
				summary: "",
				responses: {

				}
			},
			delete: {
				summary: "",
				responses: {

				}
			}
		}

	}
}
